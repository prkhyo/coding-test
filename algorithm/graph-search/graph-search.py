




# 그래프 탐색 알고리즘: DFS / BFS
# 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말함
#   특정 조건에 맞는 데이터가 존재하는지, 존재한다면 어떤 위치에 존재하는지
# 대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있음
# DFS / BFS는 코딩 테스트에서 매우 자주 등장하는 유형이므로 반드시 숙지해야 함






# 탐색 알고리즘을 구현하기 전 반드시 알아야 개념


# 1. 스택 자료구조
# 먼저 들어 온 데이터가 나중에 나가는 형식(선입후출)의 자료구조
# 입구와 출구가 동일한 형태로 스택을 시각화할 수 있음
# (ex) 박스 쌓기  
# BFS 알고리즘 뿐 아니라 다양한 알고리즘에서 사용되기 때문에 스택 자료구조의 동작 방법과 사용방법에 대한 숙지는 필수!


# 스택 동작
# 삽입과 삭제 두 연산으로 이루어짐


# 스택 구현 예제
# 파이썬에서 스택 자료구조를 구현하기 위해서는 별도의 다른 표준 라이브러리를 이용할 필요없이
# 기본적으로 제공되는 객체인 리스트 자료형을 사용하면 됨
# 리스트 자료형은 가장 오른쪽에 원소를 삽입하는 append() 메서드와 가장 오른쪽에서부터 원소를 꺼내는 pop() 메서드를 지원
# 이를 그대로 사용하여 스택 자료구조를 구현할 수 있음
# append()와 pop()의 시간복잡도 -> 상수 시간 복잡도 -> 스택 자료구조에 사용하기 적합

stack = [] 

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.append(4)
stack.pop()

print(stack[::-1]) # 최상단 원소부터 출력 [1, 3, 2, 5]
print(stack)       # 최하단 원소부터 출력 [5, 2, 3, 1]
 




# 2. 큐 자료구조
# 먼저 들어 온 데이터가 먼저 나가는 형식(선입선출)의 자료구조
# 큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태로 시각화 할 수 있음
# (ex) 터널


# 큐 동작
# 삽입과 삭제 두 연산으로 이루어짐 


# 큐 구현 예제
# 파이썬에서 큐 자료구조를 구현하기 위해서는 deque 라이브러리를 사용
# 덱은 스택과 큐 자료구조의 장점을 합친 형태의 자료구조로 볼 수 있음
# 가장 오른쪽에 원소를 삽입하는 append() 메서드와 가장 왼쪽에서부터 원소를 꺼내는 popleft() 메서드를 지원
# 단순히 리스트 자료형을 이용해서 큐 자료구조를 구현할 수도 있지만 리스트 자료형을 이용하는 경우
# 기능적으로는 큐를 구현할 수 있지만 시간복잡도가 더 높아서 비효율적으로 동작할 수가 있음


from collections import deque

# 큐 구현을 위해 deque 라이브러리 사용
queue = deque()

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue)    # 먼저 들어온 순서대로 출력    deque([3, 7, 1, 4])
queue.reverse() # 역숙으로 바꾸기
print(queue)    # 나중에 들어온 원소부처 출력  deque([4, 1, 7, 3])






# 3. 재귀 함수(Recursive Function)
# 재귀 함수란 자기 자신을 다시 호출하는 함수를 의미
# DFS를 실질적으로 구현하고자 할 때 자주 사용되는 방법 중 하나 -> 반드시 숙지!
# 단순한 형태의 재귀 함수 예제
#  '재귀 함수를 호출합니다.'라는 문자열을 무한히 출력
#  어느 정도 출력하다가 최대 재귀 깊이 초과 메세지가 출력 
#  -> 파이썬에서는 최대 재귀 깊이 제한이 있기 때문에 별 다른 설정 없이도 재귀 함수를 호출했을 때
#     최대 재귀 깊이가 초과되었다는 오류 메세지 출력 후 프로그램이 종료될 수 있음

 def recursive_function():
     print('재귀 함수를 호출합니다.')
     recursive_function()

 recursive_function()    



# 재귀 함수의 종료 조건
# 재귀 함수를 문제 풀이에서 사용할 때는 재귀 함수의 종료 조건을 반드시 명시해야 함
# 종료 조건을 제대로 명시하지않으면 함수가 무한히 호출될 수 있음



# 종료 조건을 포함한 재귀 함수 예제

def recursive_function(i):
    # 100번째 호출을 했을 때 종료되도록 종료 조건 명시
    if i == 100:
        return
    print(i, '번째 재귀함수에서', i + 1, '번째 재귀함수를 호출합니다.')
    recursive_function(i + 1)
    print(i, '번째 재귀함수를 종료합니다.')    

recursive_function(1)    

# 1 번째 재귀함수에서 2 번째 재귀함수를 호출합니다.
# 2 번째 재귀함수에서 3 번째 재귀함수를 호출합니다.
# 3 번째 재귀함수에서 4 번째 재귀함수를 호출합니다.
# 4 번째 재귀함수에서 5 번째 재귀함수를 호출합니다.
#                    ...
# 96 번째 재귀함수에서 97 번째 재귀함수를 호출합니다.
# 97 번째 재귀함수에서 98 번째 재귀함수를 호출합니다.
# 98 번째 재귀함수에서 99 번째 재귀함수를 호출합니다.
# 99 번째 재귀함수에서 100 번째 재귀함수를 호출합니다.
# 99 번째 재귀함수를 종료합니다.
# 98 번째 재귀함수를 종료합니다.
# 97 번째 재귀함수를 종료합니다.
# 96 번째 재귀함수를 종료합니다.
#            ...
# 4 번째 재귀함수를 종료합니다.
# 3 번째 재귀함수를 종료합니다.
# 2 번째 재귀함수를 종료합니다.
# 1 번째 재귀함수를 종료합니다.

# 재귀 함수를 이용하게 되면 마치 스택에 데이터를 넣었다가 꺼내는 것과 마찬가지로 
# 각각의 함수에 대한 정보가 실제로 스택 프레임에 담기며 차례대로 호출되었다가 
# 다시 가장 마지막에 호출된 함수부터 차례대로 종료가 되어 결과적으로 첫 번째에 호출했던 시점의 함수까지 종료



# 재귀 함수를 이용하는 몇 가지 예제

# 팩토리얼 구현 예제
# n! = 1 x 2 x 3 x ... x (n-1) x n    -> 1부터 n까지의 자연수를 차례대로 곱한 결과
# 수학적으로 0! 과 1! 의 값은 1







