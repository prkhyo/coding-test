

# 문자열 자료형
# 문자열 변수를 초기화할 때는 큰 따옴표(")나 작은 따옴표(')를 이용

# 문자열 안에 큰 따옴표나 작은 따옴표가 포함되어야 하는 경우
# 전체 문자열을 큰 따옴표로 구성할 때, 내부적으로 작은 따옴표를 포함할 수 있음
# 전체 문자열을 작은 따옴표로 구성할 때, 내부적으로 큰 따옴표를 포함할 수 있음
# 백슬래시(\)를 사용하면, 큰 따옴표나 작은 따옴표를 원하는 만큼 포함시킬 수 있음


data = 'Hello World'
print(data) # Hello World

data = "Don't you know \"Python\"?"
print(data) # Don't you know "Python"?



# 문자열 연산
# 문자열 변수에 덧셈(+)을 이용하면 문자열이 더해져서 연결됨
# 문자열 변수를 특정한 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해짐
# 문자열에 대해서도 인덱싱과 슬라이싱 이용 가능
# 다만, 문자열은 특정 인덱스의 값을 변경할 수 없음(변경 불가능한 객체)

a = 'hi'
b = 'hyojin'
print(a + ' '+ b) # hi hyojin

a = "String"
print(a * 4)  # StringStringStringString

a = "ABCDEF"
print(a[2:4]) # CD 







# 튜플 자료형
# 튜플 자료형은 리스트와 유사하지만 문법적 차이가 존재
# 튜플은 리스트와 달리 한 번 선언된 값을 변경할 수 없음(특정한 인덱스의 값 변경 불가능, 변경 불가능한 객체)
# 리스트는 대괄호[]를 이용하지만, 튜플은 소괄호() 를 이용
# 튜플은 리스트에 비해 상대적으로 공간 효율적 (기능이 제한적이기 때문 적은 양의 메모리 사용)

# 특정한 데이터에 접근할 때는 리스트와 마찬가지로 사용

a = (1, 2, 3, 4, 5, 6, 7, 8)

# 5 번째 원소 출력
print(a[4]) # 5

# 3 번째 원소부터 7 번째 원소까지 출력
print(a[2 : 7]) # (3,4,5,6,7)





# 튜플을 사용하면 좋은 경우

# (1) 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
#    - 최단 경로 알고리즘에서는 (비용-실수, 노드 번호-정수)의 형태로 튜플 자료형을 자주 사용
# ex (학번-정수, 이름-문자열) 등

# (2) 데이터의 나열을 해싱(Hashing)의 키 값으로 사용해야 할 때
#    - 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있음

# (3) 리스트보다 메모리를 효율적으로 사용해야 할 때


a = (1,'Tom') # (1, 'Tom')
print(a)







# 사전 자료형
# 사전 자료형은 키(key)와 값(value)의 쌍을 데이터로 가지는 자료형
# 원하는 '변경 불가능한 자료형'을 키로 사용할 수 있음
# 리스트나 튜플이 값을 순차적으로 저장하는 것과는 대비됨 -> 인덱스가 아닌 키값을 이용하여 각 원소에 접근
# 내부적으로 해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있음
# 문자열과 같은 변경불가능한 키를 이용하여 어떠한 데이터를 저장/관리하고자 하는 상황에서는 일반적으로 리스트보다 훨씬 효율적 -> 데이터의 조회를 상대적으로 더 빠르게 수행


# 변수명 = dict()     -> 사전 자료형 초기화 -> dict()함수 사용
# 변수명[key] = value
# json 형태로도 데이터 초기화 가능


data1 = dict() 
data2 = dict() 

# 1번 방법
data1['사과'] = 'apple'
data1['바나나'] = 'banana'
data1['복숭아'] = 'peach'


# 2번 방법
data2 = {
     '사과' : 'apple',
     '바나나' : 'banana',
     '복숭아' : 'peach'
}


print(data1) # {'사과': 'apple', '바나나': 'banana', '복숭아': 'peach'}
print(data2) # {'사과': 'apple', '바나나': 'banana', '복숭아': 'peach'}

print(data1['사과'])  # apple


# dict 객체에 특정한 키가 존재하는지 검사
if '바나나' in data1:
   print('바나나 데이터 존재') # 바나나 데이터 존재





# 사전 자료형 관련 메서드
# 사전 자료형에서는 키와 값을 별도로 뽑아내기 위한 메서드를 지원

# keys(): 키 데이터만 뽑아서 리스트로 이용할 때 사용    
# values(): 값 데이터만 뽑아서 리스트로 이용할 때 사용

# keys() 함수나 values() 함수의 결과값은 객체형으로 반환 됨
# 리스트 형태로 반환하기 위해서는 list로 형변환해줘야 함

data = dict();
data['파랑'] = 'blue'
data['노랑'] = 'yellow'
data['빨강'] = 'red'


key_set = data.keys()
print(key_set)    # dict_keys(['파랑', '노랑', '빨강'])
value_set = data.values()
print(value_set)  # dict_values(['blue', 'yellow', 'red']) 



# 각 키에 따른 값을 하나씩 출력
for key in key_set:
  print(data[key])  #blue  yellow  red


 
 # 사전 자료형 형변환
a = dict()
a = {
  'Tom' : 97,
  'Sam' : 60,
  'Jane' : 100,
  'Sara' : 80
}

print(a) # {'Tom': 97, 'Sam': 60, 'Jane': 100, 'Sara': 80}

key_list = a.keys()
print(key_list)    # dict_keys(['Tom', 'Sam', 'Jane', 'Sara']) -> 객체형으로 반환

key_list = list(a.keys()) # list로 형변환
print(key_list)    # ['Tom', 'Sam', 'Jane', 'Sara'] -> 리스트형으로 반환



# 특정 키의 값 출력
print(a['Sara'])   # 80




  



  